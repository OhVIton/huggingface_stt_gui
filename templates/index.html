<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>音声文字起こしプレイグラウンド (非同期版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .container { max-width: 800px; margin: 0 auto; padding: 20px; }
        .upload-box { border: 2px dashed #cbd5e1; padding: 40px; text-align: center; border-radius: 8px; cursor: pointer; transition: background-color 0.3s; }
        .upload-box:hover { background-color: #f1f5f9; }
        .upload-box input[type="file"] { display: none; }
        .message { padding: 10px; border-radius: 8px; margin-top: 15px; }
        .error-message { color: #e53e3e; background-color: #fed7d7; border: 1px solid #f56565; }
        .info-message { color: #3182ce; background-color: #bee3f8; border: 1px solid #63b3ed; }
        .success-message { color: #2f855a; background-color: #c6f6d5; border: 1px solid #68d391;}
        .task-item { border: 1px solid #e2e8f0; padding: 10px; margin-bottom:10px; border-radius: 8px; background-color: #f8fafc; }
        .task-item p { margin-bottom: 0.5em; }
        .task-id { font-family: monospace; background-color: #e2e8f0; padding: 0.2em 0.4em; border-radius: 4px; font-size:0.9em; }
        .progress-bar-container { width: 100%; background-color: #e2e8f0; border-radius: 4px; overflow: hidden; height: 8px; margin-top:5px; }
        .progress-bar { width: 0%; height: 100%; background-color: #4ade80; /* green-400 */ transition: width 0.3s ease-in-out; }
        .progress-bar.processing { background-color: #60a5fa; /* blue-400 */}
        .delete-task-button {
            background-color: #fee2e2; /* red-100 */
            color: #dc2626; /* red-600 */
            border: 1px solid #fecaca; /* red-200 */
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem; /* text-xs */
            border-radius: 0.375rem; /* rounded-md */
            transition: background-color 0.2s;
            float: right; /* 右寄せ */
        }
        .delete-task-button:hover {
            background-color: #fecaca; /* red-200 */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div class="container bg-white shadow-lg rounded-lg mt-10 p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl font-bold text-blue-600">音声文字起こしプレイグラウンド (非同期版)</h1>
        </header>

        <div id="global-message-area" class="mb-4"></div>
        
        <form id="upload-form" class="mb-8">
            <div class="mb-6">
                <label for="model-name-input" class="block text-sm font-medium text-gray-700 mb-1">Hugging Face モデル名:</label>
                <input type="text" id="model-name-input" name="model_name" 
                       class="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md p-2"
                       placeholder="例: openai/whisper-base">
            </div>

            <label for="audio-file-input" class="upload-box block hover:bg-blue-50">
                <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48"><path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /></svg>
                <span class="mt-2 block text-sm font-medium text-gray-700">音声ファイルを選択</span>
                <span id="file-name-display" class="mt-1 block text-xs text-gray-500"></span>
                <input id="audio-file-input" name="audio_file" type="file" accept="audio/*" class="sr-only">
            </label>
            
            <div class="mt-6 text-center">
                <button type="submit" id="submit-button" class="w-full sm:w-auto inline-flex justify-center items-center px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700">
                    <span id="button-text">文字起こしタスク実行</span>
                </button>
            </div>
        </form>

        <h2 class="text-xl font-semibold text-gray-700 mb-4 mt-10">タスク状況</h2>
        <div id="task-list" class="space-y-4">
            <p id="no-tasks-message" class="text-gray-500">現在実行中のタスクはありません。</p>
            </div>
    </div>

    <footer class="text-center py-8 text-sm text-gray-500">
        <p>&copy; {{ current_year | default('2025') }} 音声文字起こしプレイグラウンド</p>
    </footer>

    <script>
        const uploadForm = document.getElementById('upload-form');
        const audioFileInput = document.getElementById('audio-file-input');
        const modelNameInput = document.getElementById('model-name-input');
        const fileNameDisplay = document.getElementById('file-name-display');
        const submitButton = document.getElementById('submit-button');
        const taskListDiv = document.getElementById('task-list');
        const noTasksMessage = document.getElementById('no-tasks-message');
        const globalMessageArea = document.getElementById('global-message-area');
        const defaultModelName = 'openai/whisper-base';
        const TASK_IDS_STORAGE_KEY = 'transcription_task_ids';
        const MODEL_NAME_STORAGE_PREFIX = 'model_for_task_'; // モデル名をタスクIDに関連付けて保存するためのプレフィックス
        let pollingIntervals = {}; // To store interval IDs for each task

        function displayGlobalMessage(message, type = 'info') {
            globalMessageArea.innerHTML = `<div class="message ${type}-message">${message}</div>`;
        }

        function loadModelNameFromStorage() {
            const storedModel = localStorage.getItem('hf_model_name');
            modelNameInput.value = storedModel || defaultModelName;
        }

        function saveModelNameToStorage() {
            localStorage.setItem('hf_model_name', modelNameInput.value.trim() || defaultModelName);
        }
        
        audioFileInput.addEventListener('change', () => {
            fileNameDisplay.textContent = audioFileInput.files.length > 0 ? audioFileInput.files[0].name : '';
        });

        uploadForm.addEventListener('submit', async function(event) {
            event.preventDefault();
            saveModelNameToStorage();

            if (!audioFileInput.files.length) {
                displayGlobalMessage('エラー: 音声ファイルを選択してください。', 'error');
                return;
            }

            submitButton.disabled = true;
            submitButton.querySelector('#button-text').textContent = '送信中...';
            displayGlobalMessage('タスクをサーバーに送信しています...', 'info');

            const formData = new FormData();
            formData.append('audio_file', audioFileInput.files[0]);
            const currentModelName = modelNameInput.value.trim() || defaultModelName;
            formData.append('model_name', currentModelName);

            try {
                const response = await fetch("{{ url_for('submit_task') }}", {
                    method: 'POST',
                    body: formData,
                });

                const data = await response.json();

                if (response.ok && data.task_id) {
                    displayGlobalMessage(`タスク ${data.task_id} を受付ました。処理を開始します。`, 'success');
                    addOrUpdateTaskInList(data.task_id, data.model_name_used || currentModelName);
                    storeTaskId(data.task_id, data.model_name_used || currentModelName); // モデル名も一緒に保存
                    pollTaskStatus(data.task_id);
                } else {
                    displayGlobalMessage(`エラー: ${data.error || 'タスクの送信に失敗しました。'}`, 'error');
                }
            } catch (error) {
                console.error('送信エラー:', error);
                displayGlobalMessage(`送信エラー: ${error.message}`, 'error');
            } finally {
                submitButton.disabled = false;
                submitButton.querySelector('#button-text').textContent = '文字起こしタスク実行';
                audioFileInput.value = ''; // Clear file input
                fileNameDisplay.textContent = '';
            }
        });

        function addOrUpdateTaskInList(taskId, modelName, initialStatus = '状態確認中...') {
            if (noTasksMessage) noTasksMessage.style.display = 'none';

            let taskItem = document.getElementById(`task-${taskId}`);
            if (!taskItem) {
                taskItem = document.createElement('div');
                taskItem.id = `task-${taskId}`;
                taskItem.className = 'task-item';
                taskListDiv.prepend(taskItem); // Add new tasks to the top
            }

            taskItem.innerHTML = `
                <button class="delete-task-button" data-task-id="${taskId}" title="このタスクをリストから削除">×</button>
                <p><strong>タスクID:</strong> <span class="task-id">${taskId}</span></p>
                <p><strong>モデル:</strong> <span class="model-name-display">${modelName || 'N/A'}</span></p>
                <p><strong>状態:</strong> <span class="status-text">${initialStatus}</span></p>
                <div class="progress-bar-container">
                    <div class="progress-bar"></div>
                </div>
                <div class="transcription-result mt-2 p-2 bg-white border rounded whitespace-pre-wrap" style="display:none;"></div>
                <div class="error-details mt-2 p-2 text-red-700 bg-red-100 border-red-300 rounded" style="display:none;"></div>
                <button class="download-txt-button mt-2 px-3 py-1 border border-gray-300 text-sm rounded text-gray-700 bg-white hover:bg-gray-50" style="display:none;">TXTダウンロード</button>
            `;
            // 削除ボタンにイベントリスナーを追加
            taskItem.querySelector('.delete-task-button').addEventListener('click', handleDeleteTask);
        }
        
        function updateTaskProgressUI(taskItem, percentage, statusText) {
            const progressBar = taskItem.querySelector('.progress-bar');
            const statusTextElement = taskItem.querySelector('.status-text');
            if(progressBar) {
                progressBar.style.width = `${percentage}%`;
                if (statusText.includes('処理中') || statusText.includes('モデル準備中')) {
                    progressBar.classList.add('processing');
                } else {
                     progressBar.classList.remove('processing');
                }
            }
            if(statusTextElement) statusTextElement.textContent = statusText;
        }

        async function pollTaskStatus(taskId) {
            const taskItem = document.getElementById(`task-${taskId}`);
            if (!taskItem) { // タスクアイテムがUIから削除されていたらポーリング停止
                clearInterval(pollingIntervals[taskId]);
                delete pollingIntervals[taskId];
                return;
            }
            
            const modelNameDisplay = taskItem.querySelector('.model-name-display');

            pollingIntervals[taskId] = setInterval(async () => {
                if (!document.getElementById(`task-${taskId}`)) { // 再度チェック (インターバル中に削除される可能性)
                    clearInterval(pollingIntervals[taskId]);
                    delete pollingIntervals[taskId];
                    return;
                }
                try {
                    const response = await fetch(`{{ url_for('get_task_status', task_id='TASK_ID_PLACEHOLDER') }}`.replace('TASK_ID_PLACEHOLDER', taskId));
                    if (!response.ok) {
                        console.error(`タスク ${taskId} の状態取得エラー: ${response.status}`);
                        updateTaskProgressUI(taskItem, 0, `状態取得エラー (${response.status})`);
                        // 404 (Not Found) の場合はタスクがサーバーに存在しない可能性が高いのでポーリング停止
                        if (response.status === 404) {
                             updateTaskProgressUI(taskItem, 0, `タスクが見つかりません (サーバー確認)`);
                             clearInterval(pollingIntervals[taskId]);
                             delete pollingIntervals[taskId];
                        }
                        return;
                    }
                    const data = await response.json();
                    
                    const statusTextElement = taskItem.querySelector('.status-text');
                    const transcriptionResultDiv = taskItem.querySelector('.transcription-result');
                    const errorDetailsDiv = taskItem.querySelector('.error-details');
                    const downloadButton = taskItem.querySelector('.download-txt-button');

                    if (modelNameDisplay && data.model && data.model !== 'N/A') { // モデル名が取得できたら更新
                        modelNameDisplay.textContent = data.model;
                    }
                    statusTextElement.textContent = data.status_message || data.state;
                    
                    if (data.state === 'PROGRESS') {
                        updateTaskProgressUI(taskItem, 50, data.status_message || '処理中...'); 
                    } else if (data.state === 'SUCCESS') {
                        updateTaskProgressUI(taskItem, 100, data.status_message || '処理完了');
                        transcriptionResultDiv.textContent = data.transcription;
                        transcriptionResultDiv.style.display = 'block';
                        downloadButton.style.display = 'inline-block';
                        downloadButton.onclick = () => downloadText(taskId, data.transcription);
                        clearInterval(pollingIntervals[taskId]);
                        delete pollingIntervals[taskId];
                        taskItem.querySelector('.progress-bar').classList.remove('processing');
                        taskItem.querySelector('.progress-bar').style.backgroundColor = '#4ade80'; 
                    } else if (data.state === 'FAILURE') {
                        updateTaskProgressUI(taskItem, 100, data.status_message || 'エラー');
                        errorDetailsDiv.textContent = `エラー詳細: ${data.error || '不明なエラー'}`;
                        errorDetailsDiv.style.display = 'block';
                        clearInterval(pollingIntervals[taskId]);
                        delete pollingIntervals[taskId];
                        taskItem.querySelector('.progress-bar').style.backgroundColor = '#f87171'; 
                    } else if (data.state === 'PENDING') {
                        updateTaskProgressUI(taskItem, 10, data.status_message || '待機中...');
                    }

                } catch (error) {
                    console.error('ポーリングエラー:', error);
                    updateTaskProgressUI(taskItem, 0, 'ポーリング中にエラー発生');
                    clearInterval(pollingIntervals[taskId]); 
                    delete pollingIntervals[taskId];
                }
            }, 3000); 
        }

        function downloadText(taskId, textContent) {
            const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `transcription_${taskId.substring(0,8)}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function getStoredTasks() { // オブジェクトの配列としてタスクIDとモデル名を取得
            const stored = localStorage.getItem(TASK_IDS_STORAGE_KEY);
            return stored ? JSON.parse(stored) : [];
        }

        function storeTaskId(taskId, modelName) { // タスクIDとモデル名をオブジェクトとして保存
            let tasks = getStoredTasks();
            // 既に同じIDのタスクがあれば更新、なければ追加
            const existingTaskIndex = tasks.findIndex(task => task.id === taskId);
            if (existingTaskIndex > -1) {
                tasks[existingTaskIndex].model = modelName; // モデル名を更新
            } else {
                tasks.unshift({ id: taskId, model: modelName }); // 新しいタスクを先頭に追加
            }
            tasks = tasks.slice(0, 10); // 最新10件に制限
            localStorage.setItem(TASK_IDS_STORAGE_KEY, JSON.stringify(tasks));
        }
        
        function removeTaskIdFromStorage(taskIdToRemove) {
            let tasks = getStoredTasks();
            tasks = tasks.filter(task => task.id !== taskIdToRemove);
            localStorage.setItem(TASK_IDS_STORAGE_KEY, JSON.stringify(tasks));
            localStorage.removeItem(MODEL_NAME_STORAGE_PREFIX + taskIdToRemove); // 古い形式のモデル名も削除 (念のため)
        }

        function handleDeleteTask(event) {
            const taskId = event.target.dataset.taskId;
            if (confirm(`タスク ${taskId.substring(0,8)}... をリストから削除しますか？\n(サーバー上の処理は停止しません)`)) {
                // ポーリングを停止
                if (pollingIntervals[taskId]) {
                    clearInterval(pollingIntervals[taskId]);
                    delete pollingIntervals[taskId];
                }
                // LocalStorageから削除
                removeTaskIdFromStorage(taskId);
                // UIから削除
                const taskItem = document.getElementById(`task-${taskId}`);
                if (taskItem) {
                    taskItem.remove();
                }
                // タスクがなくなったら「タスクはありません」メッセージを再表示
                if (taskListDiv.children.length === 0 || (taskListDiv.children.length === 1 && taskListDiv.children[0].id === 'no-tasks-message')) {
                     if(noTasksMessage) noTasksMessage.style.display = 'block';
                }
                 displayGlobalMessage(`タスク ${taskId.substring(0,8)}... をリストから削除しました。`, 'info');
            }
        }

        function loadAndPollStoredTasks() {
            const tasks = getStoredTasks();
            if (tasks.length > 0) {
                if (noTasksMessage) noTasksMessage.style.display = 'none';
                tasks.forEach(task => {
                    addOrUpdateTaskInList(task.id, task.model, '状態確認中...');
                    pollTaskStatus(task.id); 
                });
            } else {
                 if(noTasksMessage) noTasksMessage.style.display = 'block';
            }
        }
        
        // Initialize
        window.addEventListener('load', () => {
            loadModelNameFromStorage();
            modelNameInput.addEventListener('change', saveModelNameToStorage);
            loadAndPollStoredTasks(); 
        });
    </script>
</body>
</html>
